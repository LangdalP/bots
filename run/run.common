DEF_CPUS=all
DEF_VERSIONS=all

print_help()
{
	echo "$0 [options]"
	echo "Where options are:"
	echo "-c cpus_list		List of number of cpus to use for executions"
	echo "-C class_list		List of execution classes to use"
	echo "-check			Enable verification"
	echo "-debug			Show extra messages"
	echo "-h			Prints this help"
	echo "-i inputs_list		List of inputs to use for executions"
	echo "-v versions_list		List of versions of the benchmark to use for execution"
	echo "-verbose 0|1|2		Set application verbosity"
	echo "-of			Output format (TODO)"
}

parse_args ()
{
	while [ "$1" ]; do
		case $1 in
			"-c")   shift; ARG_CPUS=$1
				;;
			"-C")   shift; ARG_CLASSES=$1
				;;
			"-check")
			        VERIFY="-c"
				;;
			"-debug") VERBOSE=yes
				;;
			"-h") 	print_help $0; exit 
				;;
			"-i")   shift; ARG_INPUTS=$1
				;;
			"-v")   shift; ARG_VERSIONS=$1
				;;
			"-verbose")
				shift; EXTRA="$EXTRA -v $1"
				;;
			*)
				echo "Unkown option $1"; print_help $0; exit
				;;
		esac	
	shift
	done
}

parse_class_file ()
{
	local file=$CLASS_DIR/$1
	shift

	while read line; do
		if [ "${line:0:1}" = "[" ]; then
			local n=${#line}
			local class=${line:1:n-2}

			# is one of the class definitions we want to load?
			# otherwise skip
			skip=true
			for c in $*; do
				if [ $c = $class ]; then
					skip=
					break
				fi	
			done
		else
			[ "$skip" ] && continue
			key=${line%=*}
			value=${line#*=}
	
			case $key in
				sizes) CLASS_INPUTS="$CLASS_INPUTS $value";;
				inputs) CLASS_INPUTS="$CLASS_INPUTS $value";;
			esac
		fi
	done < $file
}


compute_max_cpus ()
{
#TODO: Add other systems here
	case $(uname -s) in
		"Linux") max_cpus=$(cat /proc/cpuinfo  | grep ^processor | wc -l)
				;;
		"AIX") max_cpus=$(lsdev -Sa -Cc processor | wc -l)
				;;
		*) echo "WARNING: Don't know how to compute max cpus in this enviroment. Defaulting to 1"
		   max_cpus=1
		   ;;
	esac
}


expand_cpus ()
{
	local tmp=$(echo $CPUS | tr , ' ' )

	CPUS=
	for cpus in $tmp; do
		if echo $cpus | egrep "^[0-9]+$" > /dev/null; then
			#is a number
			CPUS="$CPUS $cpus"
		elif echo $cpus | grep "\.\." > /dev/null; then
			#is a range, range format is low..upper[/step]

			low=${cpus%..*}
			upper=${cpus#*..}

			if echo $upper | grep / > /dev/null; then
				step=${upper#*/}
				upper=${upper%/*}
			else
				step=1
			fi

			if [ "$upper" = "all" ]; then
				compute_max_cpus
				upper=$max_cpus
			fi

			CPUS="$CPUS $(seq $low $step $upper)"
			
		elif [ "$cpus" = "all" ]; then
			compute_max_cpus
			CPUS="$CPUS $max_cpus"
		fi
	done

	
}

expand_versions ()
{
	if [ "$VERSIONS" = "all" ]; then
		VERSIONS=$(ls $BIN/$APP* | sed "s|$BIN/$APP.||g")
	else
		VERSIONS=$(echo $VERSIONS | tr , '  ')
	fi
}

expand_inputs ()
{
	INPUTS=$(echo $INPUTS | tr , '  ')
}

set_values ()
{

	if [ "$ARG_CLASSES" ]; then
		parse_class_file $APP $(echo $ARG_CLASSES | tr , ' ')
	fi

	if [ "$ARG_CPUS" ]; then
		CPUS=$ARG_CPUS
	else
		CPUS=$DEF_CPUS
	fi 
	expand_cpus

	if [ "$ARG_VERSIONS" ]; then
		VERSIONS=$ARG_VERSIONS
	else
		VERSIONS=$DEF_VERSIONS
	fi 
	expand_versions

	if [ "$ARG_INPUTS" ]; then
		INPUTS=$ARG_INPUTS
	elif [ "$CLASS_INPUTS" ]; then
		INPUTS=$CLASS_INPUTS
	else
		INPUTS=$DEF_INPUTS
	fi 
	expand_inputs
}

exec_serial ()
{
	command=$BIN/$2
	cpus=$1
	shift 2

	$command $*
	return 0
}

exec_omp ()
{
	command=$BIN/$2
	cpus=$1
	shift 2

	OMP_NUM_THREADS=$cpus $command $*
}

exec_external ()
{
	local cpus=$1
	local app=$2
	local version=$3
	shift 3

	local bin=$BIN/$app.$version
	local args="$*"

	local EXEC=$EXEC_MANAGER
	[ "$file" ] && local basefile=$(basename $file | tr -d .)
	EXEC=$(echo $EXEC | sed s/%app%/$app/ | sed s/%cpus%/$cpus/ | sed s/%version%/$version/ )
	EXEC=$(echo $EXEC | sed s@%bin%@$bin@ | sed "s@%args%@$args@" | sed "s@%command%@$bin $args@" )
	if [ "$file" -o "$size" -o "$pair" ]; then
		EXEC=$(echo $EXEC | sed s@%input%@${basefile}${size}${pair}@ )
	fi

	$EXEC
}

exec_app ()
{
	app=$1
	version=$2
	cpus=$3
	shift 3

	if (echo $version | grep serial) > /dev/null; then
	   if [ "$serial_run" = "yes" ]; then
	      return 0
	   else
	      serial_run="yes"
	   fi
	fi

	[ "$EXEC_MANAGER" ] && exec_external $cpus $app $version $* && return
	(echo $version | grep serial) > /dev/null && exec_serial $cpus $app.$version $* && return
	(echo $version | grep omp) > /dev/null && exec_omp $cpus $app.$version $* && return

	echo "FATAL ERROR: Don't know how to execute $version"
	exit 1
}

exec_all_verbatim ()
{

#echo "cpus: $CPUS"
#echo "versions: $VERSIONS"
#echo "inputs: $INPUTS"

for args in $INPUTS; do
serial_run=no
for cpu in $CPUS; do
for version in $VERSIONS; do


exec_app $APP $version $cpus $args

done
done
done
}

exec_all_sizes ()
{

#echo "cpus: $CPUS"
#echo "versions: $VERSIONS"
#echo "inputs: $INPUTS"

for size in $INPUTS; do
serial_run=no
for cpus in $CPUS; do
for version in $VERSIONS; do

[ "$VERBOSE" ] && echo "Executing $APP($version) with $cpus CPUS and size $size"
exec_app $APP $version $cpus -n $size $VERIFY $EXTRA 

done
done
done
}

exec_all_files ()
{

#echo "cpus: $CPUS"
#echo "versions: $VERSIONS"
#echo "inputs: $INPUTS"

for file in $INPUTS; do
serial_run=no
for cpus in $CPUS; do
for version in $VERSIONS; do

if [ ! -e $file ]; then
	if [ -e $INPUTS_DIR/$APP/$file ]; then
		file=$INPUTS_DIR/$APP/$file
	else
		echo "Warning: Unknown input $file (skipping)"
		continue
	fi
fi 

[ "$VERBOSE" ] && echo "Executing $APP($version) with $cpus CPUS and input file $file"
exec_app $APP $version $cpus -f $file $VERIFY $EXTRA

done
done
done
}

exec_all_pairs ()
{
for pair in $INPUTS; do
serial_run=no
for cpus in $CPUS; do
for version in $VERSIONS; do


[ "$VERBOSE" ] && echo "Executing $APP($version) with $cpus CPUS and input $pair"
p1=${pair%x*}
p2=${pair#*x}
exec_app $APP $version $cpus -n $p1 -m $p2 $VERIFY $EXTRA 

done
done
done
}

if [ -z "$APP" ]; then
	APP=$(basename $0 | sed "s/run-\(.*\).sh/\1/")
fi

BIN=$BASE_DIR/bin
RUN=$BASE_DIR/run
CLASS_DIR=$BASE_DIR/config/classes
INPUTS_DIR=$BASE_DIR/inputs
